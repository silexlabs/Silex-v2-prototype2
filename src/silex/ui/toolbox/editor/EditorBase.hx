package silex.ui.toolbox.editor;

import js.Lib;
import js.Dom;

import brix.component.ui.DisplayObject;
import brix.component.navigation.Page;
import brix.util.DomTools;
import silex.property.PropertyModel;
import silex.component.ComponentModel;
import silex.layer.LayerModel;
import silex.publication.PublicationModel;
import silex.ui.dialog.FileBrowserDialog;
import silex.ui.dialog.TextEditorDialog;

/**
 * This component is the base class for all editors in Silex. 
 * Editors are Brix components, in charge of handling HTML input elements, 
 * in order to let the user enter values and edit css style values or tag attributes.
 * The name of the style or attribute is specifiyed as data-attribute-name or data-style-name
 * And the values are given as key/value pairs
 * This class handles the link with the FileBrowserDialog:
 * - opens the page file-browser-dialog when a button with class name select-file-button is clicked
 * - and calls this.selectFile to attach an event to retrieve the selected file
 * This class handles the link with the TextEditorDialog:
 * - opens the page text-editor with the TextEditor component
 * - retrieve the result and put it in selectedItem.innerHTML
 */
class EditorBase extends DisplayObject 
{
	/**
	 * Information for debugging, e.g. the class name
	 */ 
	public static inline var DEBUG_INFO:String = "silex.ui.toolbox.editor.EditorBase class";
	/**
	 * class name for the "open media lib" buttons
	 * when clicked, it will automatically open the FB and link the returned URL to a text field
	 */ 
	public static inline var OPEN_FILE_BROWSER_CLASS_NAME:String = "select-file-button";
	/**
	 * class name for the "open media lib" buttons
	 * when clicked, it will automatically open the FB and link the returned URL to a text field
	 */ 
	public static inline var ADD_MULTIPLE_FILE_BROWSER_CLASS_NAME:String = "add-multiple-files-button";
	/**
	 * The css class name of the "edit text" button
	 */
	public static inline var OPEN_TEXT_EDITOR_CLASS_NAME = "property-editor-edit-text";
	/**
	 * selected element
	 */ 
	public var selectedItem(default, setSelectedItem):HtmlDom;
	/**
	 * prevent the refresh action generated by our modifications on the model
	 */
	private var propertyChangePending:Bool = false;
	/**
	 * Constructor
	 * Start listening the input events
	 */
	public function new(rootElement:HtmlDom, BrixId:String){
		super(rootElement, BrixId);
		// listen to the change event of HTML inputs
		rootElement.addEventListener("input", onInput, true);
		rootElement.addEventListener("change", onInput, true);
		// link with file browser
		rootElement.addEventListener("click", onClick, true);

		// listen to the property change event
		PropertyModel.getInstance().addEventListener(PropertyModel.ON_PROPERTY_CHANGE, onPropertyChange, DEBUG_INFO);
		// listen to the component change event
		ComponentModel.getInstance().addEventListener(ComponentModel.ON_SELECTION_CHANGE, onSelectComponent, DEBUG_INFO);
		// listen to the component change event
		LayerModel.getInstance().addEventListener(LayerModel.ON_SELECTION_CHANGE, onSelectLayer, DEBUG_INFO);

		reset();
	}
	////////////////////////////////////////////
	// Load, apply and reset: display or apply the properties of the selected HTML dom element
	////////////////////////////////////////////
	/**
	 * reset the values
	 * this method should be implemented in the derived class
	 */
	private function reset() {
		throw("this method should be implemented in the derived class");
	}
	/**
	 * display the property value
	 * this method should be implemented in the derived class
	 */
	private function load(element:HtmlDom) {
		throw("this method should be implemented in the derived class");
	}
	/**
	 * apply the property value
	 * this method should be implemented in the derived class
	 */
	private function apply() {
		throw("this method should be implemented in the derived class");
	}
	/**
	 * lock redraw, because apply will trigger a refresh event
	 */
	private function beforeApply() {
		propertyChangePending = true;
	}
	/**
	 * unlock redraw after saving
	 */
	private function afterApply() {
		propertyChangePending = false;
	}
	////////////////////////////////////////////
	// Current selection and display
	////////////////////////////////////////////
	/**
	 * Setter for the selected item
	 * Dispatch the change event with the item reference as the detail property of the custom event
	 */
	public function setSelectedItem(item:HtmlDom):HtmlDom {
		selectedItem = item;
		refresh();
		return selectedItem;
	}
	/**
	 * refresh display
	 */
	private function refresh() {
		if (selectedItem != null)
			load(selectedItem);
		else
			reset();
	}
	////////////////////////////////////////////
	// Manipulation of the HTML input
	////////////////////////////////////////////
	/**
	 * @returns 	true if the option exists in the given select tag
	 */
	private function hasOptionValue(name:String, value:String):Bool{
		var element = DomTools.getSingleElement(rootElement, name, true);
		var options = element.getElementsByTagName("option");
		for (idx in 0...options.length){
			if(cast(options[idx]).value == value)
				return true;
		}
		return false;
	}
	/**
	 * get a list of options for the given select tag
	 */
	private function getOptions(name:String):HtmlCollection<Option>{
		var element = DomTools.getSingleElement(rootElement, name, true);
		var options = element.getElementsByTagName("option");
		return cast(options);
	}
	/**
	 * set the value of the input control with name in its class name
	 */
	private function setInputValue(name:String, value:Dynamic, inputProperty:String = "value"){
		var element = DomTools.getSingleElement(rootElement, name, true);
		Reflect.setField(element, inputProperty, value);
	}
	/**
	 * get the value from the input control with name in its class name
	 */
	private function getInputValue(name:String, inputProperty:String = "value"):Dynamic{
		var element = DomTools.getSingleElement(rootElement, name, true);
		return Reflect.field(element, inputProperty);
	}
	////////////////////////////////////////////
	// Callbacks for the view
	////////////////////////////////////////////
	/**
	 * callback for the input event, validate the data
	 */
	private function onInput(e:Event) {
		e.preventDefault();
		beforeApply();
		apply();
		afterApply();
	}
	/**
	 * callback for the click event, check if a dialog must be opened
	 */
	private function onClick(e:Event) {
		if (DomTools.hasClass(e.target, OPEN_FILE_BROWSER_CLASS_NAME)){
			e.preventDefault();
			var inputControlClassName = e.target.getAttribute("data-fb-target");
			selectFile(inputControlClassName);
		}
		else if (DomTools.hasClass(e.target, ADD_MULTIPLE_FILE_BROWSER_CLASS_NAME)){
			e.preventDefault();
			var inputControlClassName = e.target.getAttribute("data-fb-target");
			selectMultipleFiles(inputControlClassName);
		}
		else if (DomTools.hasClass(e.target, OPEN_TEXT_EDITOR_CLASS_NAME)){
			// prevent default button behaviour
			e.preventDefault();
			// open the text editor page
			openTextEditor();
		}

	}
	////////////////////////////////////////////
	// Text Editor 
	////////////////////////////////////////////
	/**
	 * open text editor
	 * called when the user clicks on a button with "property-editor-edit-text" class
	 */
	private function openTextEditor(){
		TextEditorDialog.onValidate = onTextEditorChange;
		TextEditorDialog.textContent = selectedItem.innerHTML;
		TextEditorDialog.message = "Edit text and click \"close\"";
		Page.openPage(TextEditorDialog.TEXT_EDITOR_PAGE_NAME, true, null, null, brixInstanceId);
	}
	/**
	 * callback for the TextEditorDialog
	 */
	private function onTextEditorChange(htmlText:String){
		PropertyModel.getInstance().setProperty(selectedItem, "innerHTML", htmlText);
	}
	////////////////////////////////////////////
	// File Browser 
	////////////////////////////////////////////
	/**
	 * callback for the FileBrowserDialog
	 */
	private function onFileChosen(inputControlClassName:String, fileUrl:String){
		
		var inputElement = DomTools.getSingleElement(rootElement, inputControlClassName, true);
		cast(inputElement).value = abs2rel(fileUrl);
		beforeApply();
		apply();
		afterApply();
		DomTools.doLater(refreshSelection);
	}
	/**
	 * open file browser
	 * called when the user clicks on a button with "select-file-button" class
	 */
	private function selectFile(inputControlClassName:String){
		var userMessage = "Double click to select a file!";
		var validateCallback = callback(onFileChosen, inputControlClassName);

		FileBrowserDialog.onValidate = validateCallback;
		FileBrowserDialog.message = userMessage;
		FileBrowserDialog.expectMultipleFiles = false;
		Page.openPage(FileBrowserDialog.FB_PAGE_NAME, true, null, null, brixInstanceId);
	}
	/**
	 * callback for the FileBrowserDialog
	 */
	private function onMultipleFilesChosen(inputControlClassName:String, files:Array<String>){
		
		var inputElement = DomTools.getSingleElement(rootElement, inputControlClassName, true);
		if (cast(inputElement).value != "") cast(inputElement).value += "\n";
		cast(inputElement).value += abs2rel(files.join("\n"));
		beforeApply();
		apply();
		afterApply();
		DomTools.doLater(refreshSelection);
	}
	/**
	 * open file browser
	 * called when the user clicks on a button with "select-file-button" class
	 */
	private function selectMultipleFiles(inputControlClassName:String){
		var userMessage = "Double click to select one or more file(s)!";
		var validateCallback = callback(onMultipleFilesChosen, inputControlClassName);

		FileBrowserDialog.onValidateMultiple = validateCallback;
		FileBrowserDialog.message = userMessage;
		FileBrowserDialog.expectMultipleFiles = true;
		Page.openPage(FileBrowserDialog.FB_PAGE_NAME, true, null, null, brixInstanceId);
	}
	////////////////////////////////////////////
	// Callbacks for the model
	////////////////////////////////////////////
	/**
	 * refresh the model
	 */
	private function refreshSelection(){
		if (ComponentModel.getInstance().selectedItem != null)
			ComponentModel.getInstance().refresh();
		else
			LayerModel.getInstance().refresh();
	}
	/**
	 * Callback for the PropertyModel singleton
	 * A property value has changed,
	 * @param 	e 	CustomEvent with the PropertyData object in e.detail
	 */
	private function onPropertyChange(e:CustomEvent) {
		if (propertyChangePending)
			return;

		refresh();
	}
	/**
	 * Callback for the component model event
	 * display the component style
	 */
	private function onSelectComponent(e:CustomEvent) {
		// 
		selectedItem = e.detail;
	}
	/**
	 * Callback for the layer model event
	 * display the layer style
	 */
	private function onSelectLayer(e:CustomEvent) {
		// 
		if (e.detail == null){
			selectedItem = null;
		}
		else{
			selectedItem = e.detail.rootElement;
		}
	}
	////////////////////////////////////////////
	// Helpers
	////////////////////////////////////////////
	/**
	 * convert into relative url
	 */
	private function abs2rel(url:Null<String>):Null<String>{
		if (url == null)
			return null;
			
		if (url == "")
			return "";

		var pubUrl = "publications/" + PublicationModel.getInstance().currentName + "/";
		var idxPubFolder = url.indexOf(pubUrl);
		if (idxPubFolder >= 0){
			// remove file name if there is one
			var idxSlash = pubUrl.lastIndexOf("/");
			var idxDot = pubUrl.lastIndexOf(".");
			if (idxSlash < idxDot)
				pubUrl = pubUrl.substr(idxSlash);
			// remove all the common parts
			url = url.substr(idxPubFolder + pubUrl.length);
			
		}
		return url;
	}
}