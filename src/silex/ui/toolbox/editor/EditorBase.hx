package silex.ui.toolbox.editor;

import js.Lib;
import js.Dom;

import silex.file.FileModel;
import silex.layer.LayerModel;
import silex.component.ComponentModel;
import silex.property.PropertyModel;

import brix.component.ui.DisplayObject;
import brix.util.DomTools;

import brix.component.group.IGroupable;
using brix.component.group.IGroupable.Groupable;

/**
 * This component is the base class for all editors in Silex. 
 * Editors are Brix components, in charge of editing the CSS types, 
 * Editors are "groupable", the use the html node  referenced by groupElement to communicate together,
 * for editors of the same properties, e.g. the keyword and length editors of the width CSS style
 * in order to let the user enter values and edit css style values or tag attributes.
 */
class EditorBase extends DisplayObject, implements IGroupable
{
	/**
	 * the group element set by the Group class
	 * implementation of IGroupable
	 */
	public var groupElement:HtmlDom;
	/**
	 * Information for debugging, e.g. the class name
	 */ 
	public static inline var DEBUG_INFO:String = "silex.ui.toolbox.editor.EditorBase class";
	/**
	 * selected element
	 */ 
	public var selectedItem(default, setSelectedItem):HtmlDom;
	/**
	 * prevent the refresh action generated by our modifications on the model
	 */
	private var propertyChangePending:Bool = false;
	/**
	 * store the property name, taken in the attribute "data-property-js-name" of the group node 
	 */
	private var propertyName:String;
	/**
	 * Constructor
	 * Start listening the input events
	 */
	public function new(rootElement:HtmlDom, BrixId:String){
		super(rootElement, BrixId);
		// listen to the change event of HTML inputs
		rootElement.addEventListener("input", onInput, true);
		rootElement.addEventListener("change", onInput, true);
		// link with file browser
		rootElement.addEventListener("click", onClick, true);

		// listen to the property change event
		PropertyModel.getInstance().addEventListener(PropertyModel.ON_PROPERTY_CHANGE, onPropertyChange, DEBUG_INFO);
		PropertyModel.getInstance().addEventListener(PropertyModel.ON_STYLE_CHANGE, onPropertyChange, DEBUG_INFO);
		// listen to the component change event
		ComponentModel.getInstance().addEventListener(ComponentModel.ON_SELECTION_CHANGE, onSelectComponent, DEBUG_INFO);
		// listen to the component change event
		LayerModel.getInstance().addEventListener(LayerModel.ON_SELECTION_CHANGE, onSelectLayer, DEBUG_INFO);

	}
	override public function init() : Void {
		// implementation of IGroupable
		startGroupable(rootElement);
		// group element is body element by default
		if (groupElement == null){
			trace("Warning: Editor found outside a property group.");
		}
		else{
			propertyName = groupElement.getAttribute("data-property-name");
			if (propertyName == null || propertyName == ""){
				// case of the template, will be defined later
				trace("Could not find the property name for the editor. It was not set in the attribute \"data-property-name\" of the group node ("+groupElement.className+").");
			}
		}
		try{
			reset();
		}
		catch(e:Dynamic){
			throw("Error in the implementation of the method reset: "+e);
		}
	}
	/**
	 * clean the component
	 * FIXME: here, there is memory leak due to callbacks
	 * which should be references to functions created with the keyword "callback" to avoid being encapsulted with each call 
	 */
	override public function clean() {
		super.clean();

		rootElement.removeEventListener("input", onInput, true);
		rootElement.removeEventListener("change", onInput, true);
		rootElement.removeEventListener("click", onClick, true);

		PropertyModel.getInstance().removeEventListener(PropertyModel.ON_PROPERTY_CHANGE, onPropertyChange);
		PropertyModel.getInstance().removeEventListener(PropertyModel.ON_STYLE_CHANGE, onPropertyChange);
		ComponentModel.getInstance().removeEventListener(ComponentModel.ON_SELECTION_CHANGE, onSelectComponent);
		LayerModel.getInstance().removeEventListener(LayerModel.ON_SELECTION_CHANGE, onSelectLayer);
	}

	////////////////////////////////////////////
	// Load, apply and reset: display or apply the properties of the selected HTML dom element
	////////////////////////////////////////////
	/**
	 * reset the values
	 * this method should be implemented in the derived class
	 */
	private function reset() {
		throw("this method should be implemented in the derived class");
	}
	/**
	 * display the property value
	 * this method should be implemented in the derived class
	 */
	private function load(element:HtmlDom) {
		throw("this method should be implemented in the derived class");
	}
	/**
	 * apply the property value
	 * this method should be implemented in the derived class
	 */
	private function apply() {
		throw("this method should be implemented in the derived class");
	}
	/**
	 * lock redraw, because apply will trigger a refresh event
	 */
	private function beforeApply() {
		propertyChangePending = true;
	}
	/**
	 * unlock redraw after saving
	 */
	private function afterApply() {
		propertyChangePending = false;
	}
	////////////////////////////////////////////
	// Current selection and display
	////////////////////////////////////////////
	/**
	 * Setter for the selected item
	 * Dispatch the change event with the item reference as the detail property of the custom event
	 */
	public function setSelectedItem(item:HtmlDom):HtmlDom {
		selectedItem = item;
		refresh();
		return selectedItem;
	}
	/**
	 * refresh display
	 */
	private function refresh() {
		if (selectedItem != null)
			try{
				load(selectedItem);
			}
			catch(e:Dynamic){
				throw("Error in the implementation of the method load: "+e);
			}
		else{
			try{
				reset();
			}
			catch(e:Dynamic){
				throw("Error in the implementation of the method reset: "+e);
			}
		}
	}
	////////////////////////////////////////////
	// Manipulation of the HTML input
	////////////////////////////////////////////
	/**
	 * @return 	true if the option exists in the given select tag
	 */
	private function hasOptionValue(name:String, value:String):Bool{
		var element = DomTools.getSingleElement(rootElement, name, true);
		var options = element.getElementsByTagName("option");
		for (idx in 0...options.length){
			if(cast(options[idx]).value == value)
				return true;
		}
		return false;
	}
	/**
	 * get a list of options for the given select tag
	 */
	private function getOptions(name:String):HtmlCollection<Option>{
		var element = DomTools.getSingleElement(rootElement, name, true);
		var options = element.getElementsByTagName("option");
		return cast(options);
	}
	/**
	 * set the value of the input control with name in its class name
	 */
	private function setInputValue(name:String, value:Dynamic, inputProperty:String = "value"){
		var element = DomTools.getSingleElement(rootElement, name, true);
		Reflect.setField(element, inputProperty, value);
	}
	/**
	 * get the value from the input control with name in its class name
	 */
	private function getInputValue(name:String, inputProperty:String = "value"):Dynamic{
		var element = DomTools.getSingleElement(rootElement, name, true);
		return Reflect.field(element, inputProperty);
	}
	////////////////////////////////////////////
	// Callbacks for the view
	////////////////////////////////////////////
	/**
	 * callback for the input event, validate the data
	 */
	private function onInput(e:Event) {
		e.preventDefault();
		beforeApply();
		try{
			apply();
		}
		catch(e:Dynamic){
			throw("Error in the implementation of the method apply: "+e);
		}
		afterApply();
	}
	/**
	 * callback for the click event, check if a dialog must be opened
	 */
	private function onClick(e:Event) {
	}
	////////////////////////////////////////////
	// Callbacks for the model
	////////////////////////////////////////////
	/**
	 * refresh the model
	 */
	private function refreshSelection(){
		if (ComponentModel.getInstance().selectedItem != null){
			ComponentModel.getInstance().refresh();
		}
		else if (LayerModel.getInstance().selectedItem != null){
			LayerModel.getInstance().refresh();
		}
	}
	/**
	 * Callback for the PropertyModel singleton
	 * A property value has changed,
	 * @param 	e 	CustomEvent with the PropertyData object in e.detail
	 */
	private function onPropertyChange(e:CustomEvent) {
		trace("onPropertyChange "+propertyChangePending+" - "+e.detail.name+" - "+propertyName);
		if (propertyChangePending)
			return;
		if (e.detail.name == propertyName || propertyName == null){
			// reset myself, another editor is taking care of the property
			try{
				refresh();
			}
			catch(e:Dynamic){
				throw("Error in the implementation of the method reset: "+e);
			}
		}
		else{
			// do nothing, I am not concerned
		}
	}
	/**
	 * Callback for the component model event
	 * display the component style
	 */
	private function onSelectComponent(e:CustomEvent) {
		// 
		selectedItem = e.detail;
	}
	/**
	 * Callback for the layer model event
	 * display the layer style
	 */
	private function onSelectLayer(e:CustomEvent) {
		// 
		if (e.detail == null){
			selectedItem = null;
		}
		else{
			selectedItem = e.detail.rootElement;
		}
	}
}